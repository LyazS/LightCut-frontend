# 多文件拖拽组件设计方案

## 1. 概述

将现有的单文件 `FileInputField.vue` 组件扩展为支持多文件拖拽的组件，支持：
- 最多文件数量由配置决定
- 网格布局展示缩略图
- 拖拽重新排序
- 渐进式UI设计（逐个显示上传框）

## 2. 数据结构设计

### 2.1 类型定义扩展

```typescript
// 扩展 FileInputConfig 支持多文件
export interface FileInputConfig extends BaseUIConfig {
  type: 'file-input'
  accept?: string[] // 接受的文件类型，如 ['image', 'video']
  placeholder?: I18nText // 占位符文本
  maxFiles?: number // 最大文件数量，默认为1（向下兼容）
}

// 多文件数据类型（数组形式）
export type MultiFileData = FileData[]

// 文件项状态枚举
export enum FileItemStatus {
  EMPTY = 'empty',      // 空槽位（显示上传框）
  FILLED = 'filled',    // 已填充文件
  DRAGGING = 'dragging' // 正在拖拽中
}

// 文件槽位接口
export interface FileSlot {
  index: number
  status: FileItemStatus
  fileData: FileData | null
  isDragOver: boolean
  canAcceptDrop: boolean
}
```

### 2.2 组件Props和Emits

```typescript
interface Props {
  config: FileInputConfig
  modelValue: MultiFileData // 改为数组类型
  locale: 'zh' | 'en'
}

interface Emits {
  (e: 'update:modelValue', value: MultiFileData): void
  (e: 'file-added', file: FileData, index: number): void
  (e: 'file-removed', file: FileData, index: number): void
  (e: 'files-reordered', oldIndex: number, newIndex: number): void
}
```

## 3. UI设计方案

### 3.1 Flexbox 自适应布局设计

```scss
.multi-file-container {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
  align-items: flex-start;
}

.file-slot {
  width: 120px;
  height: 120px;
  position: relative;
  flex-shrink: 0; // 防止槽位被压缩
  
  // 空槽位样式
  &.empty {
    border: 2px dashed var(--color-border-secondary);
    border-radius: var(--border-radius-small);
    background: var(--color-bg-quaternary);
  }
  
  // 已填充槽位样式
  &.filled {
    border: 2px solid transparent;
    border-radius: var(--border-radius-small);
    overflow: hidden;
  }
  
  // 拖拽状态样式
  &.drag-over-accept {
    border-color: var(--color-accent-primary);
    background: var(--color-accent-bg);
  }
  
  &.drag-over-reject {
    border-color: var(--color-error);
    background: var(--color-error-bg);
  }
}
```

### 3.2 渐进式UI逻辑

```typescript
// 计算应该显示的槽位数量
const visibleSlots = computed(() => {
  const maxFiles = props.config.maxFiles || 1
  const currentFileCount = fileList.value.length
  
  // 如果还没达到最大数量，显示一个额外的空槽位
  return Math.min(currentFileCount + 1, maxFiles)
})

// 生成槽位数据
const slots = computed((): FileSlot[] => {
  const maxFiles = props.config.maxFiles || 1
  const slots: FileSlot[] = []
  
  for (let i = 0; i < maxFiles; i++) {
    const fileData = fileList.value[i] || null
    slots.push({
      index: i,
      status: fileData ? FileItemStatus.FILLED : FileItemStatus.EMPTY,
      fileData,
      isDragOver: dragOverIndex.value === i,
      canAcceptDrop: !fileData && canAcceptMoreFiles.value
    })
  }
  
  return slots.slice(0, visibleSlots.value)
})
```

## 4. 拖拽交互设计

### 4.1 拖拽状态管理

```typescript
// 拖拽状态
const dragState = ref<{
  isDragging: boolean
  dragOverIndex: number | null
  dragSourceIndex: number | null // 内部重排序时的源索引
  canAcceptDrop: boolean
}>({
  isDragging: false,
  dragOverIndex: null,
  dragSourceIndex: null,
  canAcceptDrop: false
})

// 拖拽类型枚举
enum DragType {
  EXTERNAL = 'external', // 外部拖入（新文件）
  INTERNAL = 'internal'  // 内部重排序
}
```

### 4.2 拖拽事件处理

```typescript
// 处理外部拖拽悬停
const handleExternalDragOver = (event: DragEvent, slotIndex: number) => {
  event.preventDefault()
  
  const slot = slots.value[slotIndex]
  if (!slot.canAcceptDrop) {
    dragState.value.canAcceptDrop = false
    return
  }
  
  // 检查拖拽数据兼容性
  const targetInfo: AIGenerationPanelDropTargetInfo = {
    targetType: DropTargetType.AI_GENERATION_PANEL,
    fieldConfig: props.config,
  }
  
  const canDrop = unifiedStore.handleDragOver(event, targetInfo)
  dragState.value.canAcceptDrop = canDrop
  dragState.value.dragOverIndex = canDrop ? slotIndex : null
}

// 处理外部拖拽放置
const handleExternalDrop = async (event: DragEvent, slotIndex: number) => {
  event.preventDefault()
  
  const targetInfo: AIGenerationPanelDropTargetInfo = {
    targetType: DropTargetType.AI_GENERATION_PANEL,
    fieldConfig: props.config,
  }
  
  const result = await unifiedStore.handleDrop(event, targetInfo)
  
  if (result.success && result.data) {
    addFileAtIndex(result.data, slotIndex)
  }
  
  resetDragState()
}

// 处理内部拖拽重排序
const handleInternalDragStart = (event: DragEvent, sourceIndex: number) => {
  dragState.value.isDragging = true
  dragState.value.dragSourceIndex = sourceIndex
  
  // 设置拖拽数据
  event.dataTransfer?.setData('text/plain', `internal-reorder:${sourceIndex}`)
}

const handleInternalDrop = (event: DragEvent, targetIndex: number) => {
  event.preventDefault()
  
  const sourceIndex = dragState.value.dragSourceIndex
  if (sourceIndex !== null && sourceIndex !== targetIndex) {
    reorderFiles(sourceIndex, targetIndex)
  }
  
  resetDragState()
}
```

## 5. 文件管理逻辑

### 5.1 文件操作方法

```typescript
// 在指定位置添加文件
const addFileAtIndex = (fileData: FileData, index: number) => {
  const newList = [...fileList.value]
  newList[index] = fileData
  
  updateFileList(newList)
  emit('file-added', fileData, index)
  
  // 加载缩略图
  loadThumbnailAtIndex(fileData, index)
}

// 移除指定位置的文件
const removeFileAtIndex = (index: number) => {
  const fileData = fileList.value[index]
  if (!fileData) return
  
  const newList = [...fileList.value]
  newList.splice(index, 1)
  
  // 清理缩略图资源
  cleanupThumbnailAtIndex(index)
  
  updateFileList(newList)
  emit('file-removed', fileData, index)
}

// 重新排序文件
const reorderFiles = (fromIndex: number, toIndex: number) => {
  const newList = [...fileList.value]
  const [movedFile] = newList.splice(fromIndex, 1)
  newList.splice(toIndex, 0, movedFile)
  
  updateFileList(newList)
  emit('files-reordered', fromIndex, toIndex)
  
  // 重新加载所有缩略图
  reloadAllThumbnails()
}
```

### 5.2 缩略图管理

```typescript
// 缩略图URL映射
const thumbnailUrls = ref<Map<number, string | null>>(new Map())

// 加载指定索引的缩略图
const loadThumbnailAtIndex = async (fileData: FileData, index: number) => {
  // 清理旧的缩略图
  const oldUrl = thumbnailUrls.value.get(index)
  if (oldUrl?.startsWith('blob:')) {
    URL.revokeObjectURL(oldUrl)
  }
  
  // 生成新缩略图
  const thumbnailUrl = await generateUnifiedThumbnail(fileData)
  thumbnailUrls.value.set(index, thumbnailUrl)
}

// 清理指定索引的缩略图
const cleanupThumbnailAtIndex = (index: number) => {
  const url = thumbnailUrls.value.get(index)
  if (url?.startsWith('blob:')) {
    URL.revokeObjectURL(url)
  }
  thumbnailUrls.value.delete(index)
}

// 重新加载所有缩略图
const reloadAllThumbnails = async () => {
  for (let i = 0; i < fileList.value.length; i++) {
    const fileData = fileList.value[i]
    if (fileData) {
      await loadThumbnailAtIndex(fileData, i)
    }
  }
}
```

## 6. 自适应布局设计

### 6.1 容器样式类（简化）

```typescript
// 容器样式类（简化）
const containerClasses = computed(() => ({
  'multi-file-container': true
}))
```

### 6.2 自适应响应式设计

```scss
.multi-file-container {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
  align-items: flex-start;
  
  // 容器最小宽度，确保至少能放下一个槽位
  min-width: 120px;
  
  // 在小屏幕上保持良好的布局
  @media (max-width: 480px) {
    justify-content: center; // 小屏幕居中显示
  }
}
```

## 7. 配置扩展方案

### 7.1 配置文件示例

```json
{
  "id": "multi-image-input-example",
  "name": {
    "en": "Multi Image Input",
    "zh": "多图片输入"
  },
  "uiConfig": [
    {
      "type": "file-input",
      "label": {
        "en": "Reference Images",
        "zh": "参考图片"
      },
      "path": "aiConfig.reference_images",
      "accept": ["image", "video"],
      "maxFiles": 5,
      "placeholder": {
        "en": "Drag up to 5 images here",
        "zh": "拖拽最多5张图片到此处"
      }
    }
  ]
}
```

### 7.2 向下兼容处理

```typescript
// 配置标准化（简化）
const normalizedConfig = computed(() => {
  const config = { ...props.config }
  
  // 向下兼容：未设置maxFiles时默认为1
  if (!config.maxFiles) {
    config.maxFiles = 1
  }
  
  return config
})
```

## 8. 拖拽目标处理器修改

### 8.1 处理器接口扩展

```typescript
// 扩展拖拽结果接口
export interface MultiFileDropResult extends DropResult {
  targetIndex?: number // 目标槽位索引
  operation?: 'add' | 'replace' | 'reorder' // 操作类型
}

// 扩展目标信息接口
export interface AIGenerationPanelDropTargetInfo extends DropTargetInfo {
  targetType: DropTargetType.AI_GENERATION_PANEL
  fieldConfig: FileInputConfig
  targetIndex?: number // 目标槽位索引
  currentFiles?: MultiFileData // 当前已有文件
}
```

### 8.2 处理器逻辑修改

```typescript
// 修改handleDrop方法支持多文件
async handleDrop(
  event: DragEvent,
  dragData: UnifiedDragData,
  targetInfo: DropTargetInfo,
): Promise<MultiFileDropResult> {
  const panelTargetInfo = targetInfo as AIGenerationPanelDropTargetInfo
  const maxFiles = panelTargetInfo.fieldConfig.maxFiles || 1
  const currentFiles = panelTargetInfo.currentFiles || []
  
  // 检查是否还能添加更多文件
  if (currentFiles.length >= maxFiles) {
    return { 
      success: false, 
      error: 'Maximum file limit reached' 
    }
  }
  
  // 处理拖拽数据...
  const result = await this.processDropData(dragData, panelTargetInfo)
  
  return {
    ...result,
    targetIndex: panelTargetInfo.targetIndex,
    operation: 'add'
  }
}
```

## 9. 组件模板结构

### 9.1 Vue模板设计

```vue
<template>
  <div class="multi-file-input-field">
    <label class="field-label">
      {{ config.label[locale] }}
      <span v-if="config.maxFiles && config.maxFiles > 1" class="file-count">
        ({{ fileList.length }}/{{ config.maxFiles }})
      </span>
    </label>
    
    <div :class="containerClasses">
      <div
        v-for="slot in slots"
        :key="slot.index"
        :class="getSlotClasses(slot)"
        @dragover="handleSlotDragOver($event, slot.index)"
        @dragleave="handleSlotDragLeave($event, slot.index)"
        @drop="handleSlotDrop($event, slot.index)"
      >
        <!-- 空槽位 - 显示上传提示 -->
        <div v-if="slot.status === FileItemStatus.EMPTY" class="empty-slot">
          <component :is="IconComponents.UPLOAD" size="32px" />
          <p class="drop-hint">{{ getSlotPlaceholder(slot.index) }}</p>
        </div>
        
        <!-- 已填充槽位 - 显示文件缩略图 -->
        <div 
          v-else-if="slot.status === FileItemStatus.FILLED && slot.fileData"
          class="filled-slot"
          :draggable="canReorder"
          @dragstart="handleInternalDragStart($event, slot.index)"
        >
          <n-tooltip placement="right" :delay="300">
            <template #trigger>
              <div class="file-preview">
                <!-- 缩略图 -->
                <img
                  v-if="getThumbnailUrl(slot.index) && slot.fileData.mediaType !== 'audio'"
                  :src="getThumbnailUrl(slot.index)"
                  :alt="slot.fileData.name"
                  @error="handleThumbnailError(slot.index)"
                />
                <!-- 文件图标 -->
                <component 
                  v-else 
                  :is="getFileIcon(slot.fileData)" 
                  size="48px" 
                />
                
                <!-- 移除按钮 -->
                <button 
                  class="remove-button" 
                  @click.stop="removeFileAtIndex(slot.index)"
                >
                  <component :is="IconComponents.CLOSE" size="16px" />
                </button>
                
                <!-- 拖拽排序指示器 -->
                <div v-if="canReorder" class="drag-handle">
                  <component :is="IconComponents.DRAG" size="16px" />
                </div>
              </div>
            </template>
            
            <!-- Tooltip内容 -->
            <FileTooltipContent :file-data="slot.fileData" />
          </n-tooltip>
        </div>
      </div>
    </div>
    
    <!-- 错误信息 -->
    <div v-if="errorMessage" class="error-message">
      {{ errorMessage }}
    </div>
  </div>
</template>
```

## 10. 性能优化考虑

### 10.1 缩略图懒加载

```typescript
// 使用Intersection Observer实现懒加载
const thumbnailObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const index = parseInt(entry.target.getAttribute('data-index') || '0')
      const fileData = fileList.value[index]
      if (fileData && !thumbnailUrls.value.has(index)) {
        loadThumbnailAtIndex(fileData, index)
      }
    }
  })
})
```

### 10.2 内存管理

```typescript
// 组件卸载时清理所有资源
onUnmounted(() => {
  // 清理所有缩略图URL
  thumbnailUrls.value.forEach(url => {
    if (url?.startsWith('blob:')) {
      URL.revokeObjectURL(url)
    }
  })
  thumbnailUrls.value.clear()
  
  // 断开观察器
  thumbnailObserver.disconnect()
})
```

## 11. 实施步骤

1. **类型定义扩展** - 修改 `types.ts` 中的相关接口
2. **组件重构** - 重写 `FileInputField.vue` 组件
3. **拖拽处理器修改** - 更新 `AIGenerationPanelTargetHandler.ts`
4. **样式实现** - 编写网格布局和交互样式
5. **配置文件更新** - 更新示例配置文件
6. **测试验证** - 全面测试各种场景

## 12. 测试场景

- [ ] 单文件模式兼容性测试
- [ ] 多文件拖拽添加测试
- [ ] 文件删除功能测试
- [ ] 拖拽重排序测试
- [ ] 网格布局响应式测试
- [ ] 缩略图加载和清理测试
- [ ] 错误处理测试
- [ ] 性能压力测试

这个设计方案提供了完整的多文件拖拽功能，支持你提到的所有需求，包括渐进式UI、网格布局、拖拽重排序等功能。